// Code generated by amockgen. DO NOT EDIT.

package amockgen

import (
	"io"
	"math/big"
	"reflect"

	amock_core "github.com/ymz-ncnk/amock/core"
)

// New creates a new MxMock.
func NewMxMock() MxMock {
	return MxMock{
		Mock: amock_core.New("MxMock"),
	}
}

// MxMock is a mock implementation of the amockgen.Mx.
type MxMock struct {
	*amock_core.Mock
}

// RegisterM1 registers a function as a single M1() method call.
func (mock MxMock) RegisterM1(
	fn func(p0 int) (r0 float32)) MxMock {
	mock.Register("M1", fn)
	return mock
}

// RegisterNM1 registers a function as n M1() method calls.
func (mock MxMock) RegisterNM1(n int,
	fn func(p0 int) (r0 float32)) MxMock {
	mock.RegisterN("M1", n, fn)
	return mock
}

// UnregisterM1 unregisters M1() method calls.
func (mock MxMock) UnregisterM1() MxMock {
	mock.Unregister("M1")
	return mock
}

// RegisterM10 registers a function as a single M10() method call.
func (mock MxMock) RegisterM10(
	fn func()) MxMock {
	mock.Register("M10", fn)
	return mock
}

// RegisterNM10 registers a function as n M10() method calls.
func (mock MxMock) RegisterNM10(n int,
	fn func()) MxMock {
	mock.RegisterN("M10", n, fn)
	return mock
}

// UnregisterM10 unregisters M10() method calls.
func (mock MxMock) UnregisterM10() MxMock {
	mock.Unregister("M10")
	return mock
}

// RegisterM2 registers a function as a single M2() method call.
func (mock MxMock) RegisterM2(
	fn func(p0 *[3]string, p1 []bool) (r0 []*uint, r1 [10]big.Int)) MxMock {
	mock.Register("M2", fn)
	return mock
}

// RegisterNM2 registers a function as n M2() method calls.
func (mock MxMock) RegisterNM2(n int,
	fn func(p0 *[3]string, p1 []bool) (r0 []*uint, r1 [10]big.Int)) MxMock {
	mock.RegisterN("M2", n, fn)
	return mock
}

// UnregisterM2 unregisters M2() method calls.
func (mock MxMock) UnregisterM2() MxMock {
	mock.Unregister("M2")
	return mock
}

// RegisterM3 registers a function as a single M3() method call.
func (mock MxMock) RegisterM3(
	fn func(p0 chan error)) MxMock {
	mock.Register("M3", fn)
	return mock
}

// RegisterNM3 registers a function as n M3() method calls.
func (mock MxMock) RegisterNM3(n int,
	fn func(p0 chan error)) MxMock {
	mock.RegisterN("M3", n, fn)
	return mock
}

// UnregisterM3 unregisters M3() method calls.
func (mock MxMock) UnregisterM3() MxMock {
	mock.Unregister("M3")
	return mock
}

// RegisterM4 registers a function as a single M4() method call.
func (mock MxMock) RegisterM4(
	fn func(p0 io.Reader)) MxMock {
	mock.Register("M4", fn)
	return mock
}

// RegisterNM4 registers a function as n M4() method calls.
func (mock MxMock) RegisterNM4(n int,
	fn func(p0 io.Reader)) MxMock {
	mock.RegisterN("M4", n, fn)
	return mock
}

// UnregisterM4 unregisters M4() method calls.
func (mock MxMock) UnregisterM4() MxMock {
	mock.Unregister("M4")
	return mock
}

// RegisterM5 registers a function as a single M5() method call.
func (mock MxMock) RegisterM5(
	fn func(p0 io.Reader, p1 io.Writer) (r0 interface{}, r1 io.ReadCloser)) MxMock {
	mock.Register("M5", fn)
	return mock
}

// RegisterNM5 registers a function as n M5() method calls.
func (mock MxMock) RegisterNM5(n int,
	fn func(p0 io.Reader, p1 io.Writer) (r0 interface{}, r1 io.ReadCloser)) MxMock {
	mock.RegisterN("M5", n, fn)
	return mock
}

// UnregisterM5 unregisters M5() method calls.
func (mock MxMock) UnregisterM5() MxMock {
	mock.Unregister("M5")
	return mock
}

// RegisterM6 registers a function as a single M6() method call.
func (mock MxMock) RegisterM6(
	fn func(p0 interface{})) MxMock {
	mock.Register("M6", fn)
	return mock
}

// RegisterNM6 registers a function as n M6() method calls.
func (mock MxMock) RegisterNM6(n int,
	fn func(p0 interface{})) MxMock {
	mock.RegisterN("M6", n, fn)
	return mock
}

// UnregisterM6 unregisters M6() method calls.
func (mock MxMock) UnregisterM6() MxMock {
	mock.Unregister("M6")
	return mock
}

// RegisterM7 registers a function as a single M7() method call.
func (mock MxMock) RegisterM7(
	fn func(p0 chan int, p1 io.Writer) (r0 map[int]big.Int, r1 error)) MxMock {
	mock.Register("M7", fn)
	return mock
}

// RegisterNM7 registers a function as n M7() method calls.
func (mock MxMock) RegisterNM7(n int,
	fn func(p0 chan int, p1 io.Writer) (r0 map[int]big.Int, r1 error)) MxMock {
	mock.RegisterN("M7", n, fn)
	return mock
}

// UnregisterM7 unregisters M7() method calls.
func (mock MxMock) UnregisterM7() MxMock {
	mock.Unregister("M7")
	return mock
}

// RegisterM8 registers a function as a single M8() method call.
func (mock MxMock) RegisterM8(
	fn func(p0 map[string]int, p1 *io.Reader, p2 interface{}) (r0 *io.WriteCloser, r1 error, r2 error)) MxMock {
	mock.Register("M8", fn)
	return mock
}

// RegisterNM8 registers a function as n M8() method calls.
func (mock MxMock) RegisterNM8(n int,
	fn func(p0 map[string]int, p1 *io.Reader, p2 interface{}) (r0 *io.WriteCloser, r1 error, r2 error)) MxMock {
	mock.RegisterN("M8", n, fn)
	return mock
}

// UnregisterM8 unregisters M8() method calls.
func (mock MxMock) UnregisterM8() MxMock {
	mock.Unregister("M8")
	return mock
}

// RegisterM9 registers a function as a single M9() method call.
func (mock MxMock) RegisterM9(
	fn func(p0 *chan int, p1 io.Reader)) MxMock {
	mock.Register("M9", fn)
	return mock
}

// RegisterNM9 registers a function as n M9() method calls.
func (mock MxMock) RegisterNM9(n int,
	fn func(p0 *chan int, p1 io.Reader)) MxMock {
	mock.RegisterN("M9", n, fn)
	return mock
}

// UnregisterM9 unregisters M9() method calls.
func (mock MxMock) UnregisterM9() MxMock {
	mock.Unregister("M9")
	return mock
}

func (mock MxMock) M1(p0 int) (r0 float32) {
	result, err := mock.Call("M1", p0)
	if err != nil {
		panic(err)
	}
	r0 = result[0].(float32)
	return
}

func (mock MxMock) M10() {
	_, err := mock.Call("M10")
	if err != nil {
		panic(err)
	}
}

func (mock MxMock) M2(p0 *[3]string, p1 []bool) (r0 []*uint, r1 [10]big.Int) {
	result, err := mock.Call("M2", p0, p1)
	if err != nil {
		panic(err)
	}
	r0 = result[0].([]*uint)
	r1 = result[1].([10]big.Int)
	return
}

func (mock MxMock) M3(p0 chan error) {
	_, err := mock.Call("M3", p0)
	if err != nil {
		panic(err)
	}
}

func (mock MxMock) M4(p0 io.Reader) {
	var p0Val reflect.Value
	if p0 == nil {
		p0Val = reflect.Zero(reflect.TypeOf((*io.Reader)(nil)).Elem())
	} else {
		p0Val = reflect.ValueOf(p0)
	}
	_, err := mock.Call("M4", p0Val)
	if err != nil {
		panic(err)
	}
}

func (mock MxMock) M5(p0 io.Reader, p1 io.Writer) (r0 interface{}, r1 io.ReadCloser) {
	var p0Val reflect.Value
	if p0 == nil {
		p0Val = reflect.Zero(reflect.TypeOf((*io.Reader)(nil)).Elem())
	} else {
		p0Val = reflect.ValueOf(p0)
	}
	var p1Val reflect.Value
	if p1 == nil {
		p1Val = reflect.Zero(reflect.TypeOf((*io.Writer)(nil)).Elem())
	} else {
		p1Val = reflect.ValueOf(p1)
	}
	result, err := mock.Call("M5", p0Val, p1Val)
	if err != nil {
		panic(err)
	}
	r0, _ = result[0].(interface{})
	r1, _ = result[1].(io.ReadCloser)
	return
}

func (mock MxMock) M6(p0 interface{}) {
	var p0Val reflect.Value
	if p0 == nil {
		p0Val = reflect.Zero(reflect.TypeOf((*interface{})(nil)).Elem())
	} else {
		p0Val = reflect.ValueOf(p0)
	}
	_, err := mock.Call("M6", p0Val)
	if err != nil {
		panic(err)
	}
}

func (mock MxMock) M7(p0 chan int, p1 io.Writer) (r0 map[int]big.Int, r1 error) {
	var p1Val reflect.Value
	if p1 == nil {
		p1Val = reflect.Zero(reflect.TypeOf((*io.Writer)(nil)).Elem())
	} else {
		p1Val = reflect.ValueOf(p1)
	}
	result, err := mock.Call("M7", p0, p1Val)
	if err != nil {
		panic(err)
	}
	r0 = result[0].(map[int]big.Int)
	r1, _ = result[1].(error)
	return
}

func (mock MxMock) M8(p0 map[string]int, p1 *io.Reader, p2 interface{}) (r0 *io.WriteCloser, r1 error, r2 error) {
	var p2Val reflect.Value
	if p2 == nil {
		p2Val = reflect.Zero(reflect.TypeOf((*interface{})(nil)).Elem())
	} else {
		p2Val = reflect.ValueOf(p2)
	}
	result, err := mock.Call("M8", p0, p1, p2Val)
	if err != nil {
		panic(err)
	}
	r0 = result[0].(*io.WriteCloser)
	r1, _ = result[1].(error)
	r2, _ = result[2].(error)
	return
}

func (mock MxMock) M9(p0 *chan int, p1 io.Reader) {
	var p1Val reflect.Value
	if p1 == nil {
		p1Val = reflect.Zero(reflect.TypeOf((*io.Reader)(nil)).Elem())
	} else {
		p1Val = reflect.ValueOf(p1)
	}
	_, err := mock.Call("M9", p0, p1Val)
	if err != nil {
		panic(err)
	}
}
